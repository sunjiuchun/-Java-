# 面向对象基础

## 方法重载

**Java**：

 - 功能类似的不同参数的方法，称之为同名方法
 - 方法名相同，各自参数不同，称为方法重载`Overload`
 - 注意：方法重载的返回值通常相同
 - 举个栗子：
 
	`String`类提供了多个重载方法`indexOf()`，可以查找子串：

	`int indexOf(int ch)`：根据字符的`Unicode`码查找；

	`int indexOf(String str)`：根据字符串查找；

	`int indexOf(int ch, int fromIndex)`：根据字符查找，但指定起始位置；

	`indexOf(String str, int fromIndex)`根据字符串查找，但指定起始位置。

 - 使用方法：

   `

	public class Main {
    public static void main(String[] args) {
        String s = "Test string";
        int n1 = s.indexOf('t');
        int n2 = s.indexOf("st");
        int n3 = s.indexOf("st", 4);
        System.out.println(n1);
        System.out.println(n2);
        System.out.println(n3);
    	}
	}
    结果：3;2;5



## 继承

**Java**：

 - Java使用`extends`关键字来实现继承：

 `

	class Person {}
	class Student ectends Person {}

 - protected：子类无法访问父类的private方法或private字段，可以将private改为protected，这样修饰的方法和字段可以被子类访问。

 `

	class Person {
	    protected String name;
	    protected int age;
	}
	
	class Student extends Person {
	    public String hello() {
	        return "Hello, " + name; // OK!
	    }
	}

 - super：`super`关键字表示父类（超类）。子类引用父类的字段时，可以用`super.fieldName`
 
 `

	class Student extends Person {
    public String hello() {
        return "Hello, " + super.name;
    	}
	}
   实际上，这里使用`super.name`，或者`this.name`，或者`name`，效果都是一样的。编译器会自动定位到父类的`name`字段

   如果父类没有默认的构造方法，子类就必须显式调用`super()`，并给出参数以便让编译器定位到父类的一个合适的构造方法

   子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。

 - 向上转型

     ` Person p = new Student();//OK!`

   向上转型实际上是把一个子类型安全地变为更加抽象的父类型。

 - 向下转型

   向下转型时，可以用`instanceof`函数来判断一个变量所指向的实例是否是指定类型
  `

	Person p = new Person();
	System.out.println(p instanceof Person); // true
	System.out.println(p instanceof Student); // false

   `instanceof`实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为`null`，那么对任何`instanceof`的判断都为`false`
   `

	Person p = new Student();
	if (p instanceof Student) {
    // 只有判断成功才会向下转型:
    Student s = (Student) p; // 一定会成功
	}
   `

	public class Hello{
	public static void main(String[] args){
		Object obj = "hello";
		
		if (obj instanceof String) {
			String s = (String) obj;
			System.out.println(s.toUpperCase());
			}
		}
	}

 - 区分继承和组合

   `

	class Student extends Person {
    protected Book book;
    protected int score;
	}


   `Student`应该持有一个`Book`实例
   
## 多态

**Java**：   

 - 多态:在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，成为`Override`

`Override`和`Overload`不同的是，如果方法签名如果不同，就是`Overload`，`Overload`方法是一个新方法；如果方法签名相同，并且返回值也相同，就是`Override`
   `

	class Person {
    public void run() { … }
	}

	class Student extends Person {
    // 不是Override，因为参数不同:
    public void run(String s) { … }
    // 不是Override，因为返回值不同:
    public int run() { … }
	}

加上`@Override`可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。
   `

	public class Main {
        public static void main(String[] args) {
        }


	class Person {
        public void run() {}
	}

	    public class Student extends Person {
        @Override // Compile error!
        public void run(String s) {}
	}

   `

	public class Main {
        public static void main(String[] args) {
        Person p = new Student();
        p.run(); // 应该打印Person.run还是Student.run?
        }
	}//调用的结果是Student.run()

 - 调用`super`
 
 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用。例如：
   `
	
	class Person {
    protected String name;
    public String hello() {
        return "Hello, " + name;
      }
	}

	Student extends Person {
    @Override
    public String hello() {
        // 调用父类的hello()方法:
        return super.hello() + "!";
      }
	}
	
 - `final`
 
继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为`final`。用`final`修饰的方法不能被`Override`：
   `
	
	class Person {
    protected String name;
    public final String hello() {
        return "Hello, " + name;
    	}
	}
	Student extends Person {
    // compile error: 不允许覆写
    @Override
    public String hello() {
    	}
	}
也可以用`final`修饰类，用`final`修饰的类不能被继承

 - 小结

	子类可以覆写父类的方法（Override），覆写在子类中改变了父类方法的行为；

	Java的方法调用总是作用于运行期对象的实际类型，这种行为称为多态；

	final修饰符有多种作用：

	final修饰的方法可以阻止被覆写；

	final修饰的class可以阻止被继承；

	final修饰的field必须在创建对象时初始化，随后不可修改。

## 抽象类

**Java**：  

 - 抽象类方法：如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：

   、

	class Person {
    	public abstract void run();
	}

例如，`Person`类定义了抽象方法`run()`，那么，在实现子类`Student`的时候，就必须覆写`run()`方法：

   、

	public class Main {
    	public static void main(String[] args) {
        Person p = new Student();
        p.run();
      }
	}

	abstract class Person {
    	public abstract void run();
	}

	class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    	}
	}
 - 面向抽象编程
 
当我们定义了抽象类`Person`，以及具体的`Student`、`Teacher`子类的时候，我们可以通过抽象类`Person`类型去引用具体的子类的实例：
   、

	Person s = new Student();
	Person t = new Teacher();

这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Person类型变量的具体子类型，这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。
   、
	
	Person e = new Employee();
	e.run();
	

## 接口

**Java**：

如果一个抽象类没有字段，所有方法全部都是抽象方法：

	 abstract class Person {
    	public abstract void run();
    	public abstract String getName();
	}
就可以把该抽象类改写为接口：`interface`。

在`Java`中，使用`interface`可以声明一个接口：
	
	interface Person {
    	void run();
    	String getName();
	}	
`interface`是比抽象类还要抽象的纯抽象接口，连字段都不能有，接口定义的所有方法默认都是`public abstract`，所以这两个修饰符不需要写出来

当一个具体的`class`去实现一个`interface`时，需要使用`implements`关键字。举个例子：	 
	
	class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(this.name + " run");
    }

    @Override
    public String getName() {
        return this.name;
    }
	}

Java中，一个类只能继承自另一个类，不能从多个类继承，但是一个类可以实现多个`intetface`

	class Student implements Person, Hello { 
	// 实现了两个interface
    ...
	}		